# Basics
circle st r = let
  offset = st - vec2 0.5 0.5
  delta = r * 0.1
  dist = dot offset offset
  result = smoothstep (r - delta) (r + delta) (dist * 5.0)
  in 1.0 - result

box st size = let
  s = vec2 0.5 0.5 - size * vec2 0.5 0.5
  uv = smoothstep s (s + vec2 0.001 0.001) st
  uv2 = uv * smoothstep s (s + vec2 0.001 0.001) (vec2 1.0 1.0 - st)
  in uv2.x * uv2.y

#rotate2d a = mat4 (cos a) (-sin a) (sin a) (cos a)


# Randomness

random st = fract (sin (dot st (vec2 12.9898 78.233)) * 43758.5453123)

noise st = let
  i = floor st
  a = random i
  b = random (i + vec2 1.0 0.0)
  c = random (i + vec2 0.0 1.0)
  d = random (i + vec2 1.0 1.0)
  f = fract st
  u = f * f * (vec2 3.0 3.0 - vec2 2.0 2.0 * f)
  e = mix a b u.x 
  g = (c - a) * u.y * (1.0 - u.x)
  h = (d - b) * u.x * u.y
  in e + g + h

# TODO: this is implemented incorrectly
fbm st = let
  value_1 = 0.0
  amplitude_1 = 0.5
  noise_1 = noise st

  value_2 = value_1 + amplitude_1 * noise_1
  st_2 = st * vec2 2.0 2.0
  amplitude_2 = amplitude_1 * 0.5

  noise_2 = noise st_2
  value_3 = value_2 + amplitude_2 * noise_2
  st_3 = st_2 * vec2 2.0 2.0
  amplitude_3 = amplitude_2 * 0.5

  noise_3 = noise st_3
  value_4 = value_3 + amplitude_3 * noise_3
  st_4 = st_3 * vec2 2.0 2.0
  amplitude_4 = amplitude_3 * 0.5

  noise_4 = noise st_4
  value_5 = value_4 + amplitude_4 * noise_4
  in value_5

kaleid st nSides = let
  offset = st - vec2 0.5 0.5
  r = length st
  a = atan st.x st.y
  pi = 2.0 * 3.1416
  b = mod a (pi / nSides)
  c = abs (a - pi / nSides / 2.0)
  d = vec2 r r * vec2 (cos c) (sin c)
  in d

permute x = let
    a = x * vec4 34.0 34.0 34.0 34.0
    b = a + vec4 1.0 1.0 1.0 1.0
    c = b * x
    in mod c 289.0

taylor_inv_sqrt r = let
    s = 1.79284291400159 
    t = 0.85373472095314 
    in vec4 s s s s * vec4 t t t t * r

noise2 v = let
  C = vec2 (1.0 / 6.0) (1.0/3.0)
  D = vec4 0.0 0.5 1.0 2.0

  # First corner
  d0 = dot v C.yyy
  i = floor v + vec3 d0 d0 d0
  d1 = dot i C.xxx
  x0 = v - i + vec3 d1 d1 d1

  # Other corners
  g = step x0.yzx x0.xyz
  l = vec3 1.0 1.0 1.0 - g
  i1 = min g.xyz l.zxy
  # TODO: finish simplex noise
  in i1


hsb2rgb : Vec4 -> Vec4
hsb2rgb c = let
  red = c.x * 6.0 
  shift = vec3 red red red + vec3 0.0 4.0 2.0
  modulus = mod shift 6.0 
  unbound = abs (modulus - vec3 3.0 3.0 3.0) - vec3 1.0 1.0 1.0
  bound = clamp unbound 0.0 1.0
  rgb = bound * bound * (vec3 3.0 3.0 3.0 - vec3 2.0 2.0 2.0 * bound)
  in vec3 c.z c.z c.z * mix (vec3 1.0 1.0 1.0) rgb c.y
